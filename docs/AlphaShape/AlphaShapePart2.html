<!DOCTYPE html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="G.W. Lucas">
    <title>Implementation details for a 2D alpha shape utility</title>

    <link rel="stylesheet" href="../css/960_12_col.css" />
    <link rel="stylesheet" href="../css/text.css" />
    <link rel="stylesheet" href="../css/layout.css" />
</head>


<body>
    <div class="container_12">
        <div >
            <a class="top-link" href = "https://gwlucastrig.github.io/TinfourDocs/">Home</a>
            |
            <a class="top-link"  href="https://github.com/gwlucastrig/Tinfour">Code Repository (Github)</a>
            |
            <a class="top-link"  href="https://github.com/gwlucastrig/Tinfour/wiki">Wiki</a>
            |
            <a class="top-link"  href="AlphaShapePart1.html">Part 1: Concepts</a>
            |
            <a class="top-link"  href="AlphaShapePart3.html">Part 3: Alpha circle calculation</a>
        </div>

        <div id="notescontent">

            <div class="titleblock">
                <p class="title">
                    Implementation details for a 2D alpha shape utility<br>Part 2: Implementation
                </p>
                <p class="author">by G.W. Lucas</p>
            </div>


            <p>
                <b>Note:</b> This webpage is under construction. Some of its content
                is still evolving and may not be completely accurate.
                <strong>More content and corrections are coming soon.</strong>
            </p>

            <h1>Introduction</h1>
            <p>Part 1 of these notes introduced the concepts underlying a 2D alpha shape utility.
                This section of the notes covers the algorithms and technical details of the Tinfour
                implementation. Although the Tinfour AlphaShape class is written in Java, the ideas described
                in these notes would carry over to any development environment.</p>

            <p>The classic alpha shape definition depends on the construction of a
                <a href="https://gwlucastrig.github.io/TinfourDocs/DelaunayIntro/index.html">Delaunay triangulation</a>.
                And, naturally, the Tinfour AlphaShape code is built on top
                of the Tinfour Delaunay triangulation classes. Tinfour implements the Delaunay
                using a Java interface known as IIncrementalTin (for "incremental triangulated irregular network").
                While some of the operations described in this article depend the capabilities
                defined by that interface, all of the functions it uses should have equivalents
                in other Delaunay triangulation implementations.</p>

            <h1 id="Preliminaries">Preliminaries</h1>
            <p>Before getting into the techniques used by AlphaShape, we will briefly review the
                relevant features of Tinfour Delaunay triangulations. The figure below illustrates
                the structure of a simple triangulation based on four vertices labeled A, B, C, and D.</p>


            <img width="320" height="335" alt="Triangulation A,B,C,D"
                 title="Delaunay triangulation for 4 points" src="images2/TinfourPreliminaries1.png"/>

            <p>The following details will be relevant to our discussion of the Tinfour algorithms
                for constructing an AlphaShape from a Delaunay triangulation.</p>

            <ul>
                <li>Tinfour Delaunay triangulations implement a collection of vertices and edges.
                    Triangles are not actively maintained in memory, but may be constructed on an as-needed basis.</li>
                <li>In the classic Delaunay triangulation, pairs of vertices are linked together by bi-directional
                    edges.  Tinfour uses a "paired edge" structure in which two single-direction edges
                    are coupled together, one edge for each direction of traversal.</li>
                <li>Each Tinfour edge carries a reference to a corresponding "dual" edge that supports
                    the opposite direction of traversal. In the figure above, the edge labeled "0"
                    indicates the traversal from vertex A to B. Its dual, the edge labeled "1"
                    supports the traversal from vertex B to A.</li>
                <li>Tinfour assigns unique integer index values to each edge at the time
                    it is created. These index values allow an application to maintain
                    supplemental information about the edges they represent.</li>
                <li>To form triangles, each Tinfour edge is linked to two other edges.
                    These linked edges are referred to the "forward" edge and the "reverse"
                    edge. The Tinfour API provides methods for obtaining references to each linked edge
                    (forward, reverse, and dual).</li>
                <li>When three edges are linked together to form a triangle,
                    the triangle is always specified in counterclockwise order.</li>
            </ul>

            <p>Additional details about the Tinfour edge concept are presented in our Wiki article
                <a href="https://github.com/gwlucastrig/Tinfour/wiki/Tutorial-Using-Edge-Based-Techniques-Part-1">
                    Tutorial Using Edge Based Techniques</a>.

            <h1 id="BuildingAnAlphaShape">Building an alpha shape</h1>
            <p>The Tinfour technique for building an alpha is a three-step process:</p>
            <ol>
                <li>Create a Delaunay triangulation from a set of
                    scattered data points</li>
                <li>Use the alpha-circle criteria to identify edges from
                    the triangulation as being either a border, or interior or exterior
                    to the alpha shape (Edelsbrunner referred to exterior edges as α-exposed).</li>
                <li>Connect the border edges together to form polygons enclosing
                    the alpha shape.
                    <ul>
                        <li>An alpha shape may consist of multiple polygons.</li>
                        <li>Some polygons may include "holes" (nested polygons).</li>
                        <li>For sufficiently small radius values, it may be impossible
                            to build polygons that enclose all of the input points.
                            Some points may remain as "orphans" which must be treated
                            as isolated individuals rather than part of a polygon structure.</li>
                    </ul>
                </li>
            </ol>

            <p>The Delaunay triangulation is the focus of the Tinfour software project.
                Given a set of scattered points, the Tinfour API includes classes
                that link points into a triangle-based mesh structure that
                can be accessed through the Java interface IIncrementalTin.
                Interested readers may consult our <a href="https://gwlucastrig.github.io/TinfourDocs/">project documentation</a>
                and <a href="https://github.com/gwlucastrig/Tinfour/wiki">Wiki page</a> for
                more information.</p>



            <h1 id="IsAnEdgeExposed">Is an edge exposed?</h1>
            <p>Once a Delaunay triangulation is constructed from a set of scattered points,
                it may be passed to Tinfour's AlphaShape constructor
                along with an arbitrarily specified radius value.</p>
            <p>AlphaShape begins by classifying each edge in the Delaunay triangulation
                as either interior (α-unexposed), exterior (α-exposed), or a border according
                to the following rules:</p>
            <ul>
                <li>α-exposed: If both of the alpha circles associated with the
                    edge are empty, the edge is exterior to the alpha shape.</li>
                <li>α-unexposed: If both of the circles are occupied by distinct vertices,
                    the edge is interior to the alpha shape.</li>
                <li>border: If one of the circles is occupied by a vertex
                    and the other is empty, then the edge is a border
                    of the alpha shape
                    (see <a href="./AlphaShapePart1.html#TheCircleSelectionCriterion">The circle selection criteria</a>).
                </li>
                <li>border (Tinfour modified rule): If both circles are
                    occupied by the same vertex, but not by any others,
                    the edge is a border of the alpha shape
                    (see <a href="AlphaShapePart1.html#TinfourModifications">
                        Tinfour modifications for border identification</a>).
                </li>
            </ul>


            <p>If we had to search for every point in an input sample set in order to discover whether
                a circle is occupied or not, the processing cost for a large set of points
                might become prohibitive (on the order of N<sup>2</sup>).
                Fortunately, the nature of the Delaunay triangulation makes that
                unnecessary.
            </p>
            <p>To determine the alpha exposure value
                for any standard edge in the Delaunay triangulation, it is sufficient
                to inspect the two vertices opposite that edge. If an alpha circle
                is not occupied by either of the associated vertices, then it will not
                be occupied by any other vertices in the Delaunay triangulation.
                A typical edge/vertex situation is illustrated in the figure below</p>

            <img width="780" height="390" alt="Delaunay and Alpha Circles"
                 title="Relationship between Delaunay and alpha circles"
                 src="images2/TinfourPreliminaries2.png"/>

            <h2>Classifying an edge as a border or interior component</h2>
            <p>When both alpha circles associated with an segment (pair of edges)
                are occupied by vertices, the segment is treated as being part
                of the <i>interior</i> of the alpha shape. When both circles
                are empty, the segment is treated as being <i>exterior</i>
                to the alpha shape.
                Because the alpha circles contain a vertex on one side of segment AB, but not both,
                the segment would be treated as a border. The alpha circle to the
                right of the edge is occupied by Vertex D.  The alpha circle
                to the left is not occupied. Tinfour defines the side of the edge
                with an empty circle as being <i>exterior</i> to the alpha shape.
                The side of the edge with an occupied circle is treated as being
                in the <i>interior</i>.
            </p>
            <p>During the construction of the
                AlphaShape, Tinfour maintains an array of flags indicating which edges
                are interior to the alpha shape and which are
                borders<sup><a href="#Note1">[1]</a></sup>.
                These arrays are named covered[] and border[]. The arrays are indexed
                using the edge index as shown in the figure above<sup><a href="#Note2">[2]</a></sup>.
                In the figure above, segment AB is a border because only
                one of the alpha circles is occupied (by vertex D). The
                segment has two sides (two Tinfour edge objects) which are
                numbered 0 and 1.  In the figure, the edge to the left of
                segment, which has edge index 0, faces the exterior of the alpha shape.
                So border[0] would be set to true. The edge to the right of
                the segment, which has edge index 1, faces the interior
                of the alpha shape, so covered[0] would be set to true.
            </p>

            <h1 id="AlphaPolygons">Stitching edges together to form alpha polygons</h1>

            <p>The alpha circle criterion allows an application to identify
                a set of edges that border an alpha shape. Once the
                border segments are established, the AlphaShape
                links them together into polygons using a sweep technique
                as illustrated in the figure below. Before considering the figure,
                we note the following:</p>
            <ul>
                <li>The outward side of the edge is marked with the border flag.
                    For example, in the upper part of the image, edges 1, 15, and 21 are
                    borders.</li>
                <li>The inward side of the edge is marked with the covered
                    flag and treated as being interior to the alpha shape.
                    For example, edges 0, 14, and 20 are covered.</li>
                <li>The alpha shape polygon will consist of the inside
                    edges and be given in a counterclockwise order.</li>
            </ul>

            <img width="780" height="500" alt="Alpha shape with sweeps"
                 title="Alpha shape construction using counterclockwise sweeps"
                 src="images2/AlphaShapeWithOuterSweeps.png"/>

            <h2 id="TheBigSweep">The sweep</h2>
            <p>The sweep process begins with an
                arbitrarily chosen border edge.
                As described above, the border edge faces outward from the alpha shape.
                The logic adds the dual of the border edge (the dual is the inner facing edge)
                to the polygon. The process then searches the edges that are adjacent to the
                border by sweeping in a counterclockwise order around its initial point
                (in the figure, the sweeps are shown as loops ending with arrows). The polygon is considered
                complete when the search reaches the starting polygon.</p>
            <p>The alpha shape may contain multiple polygons.  Once
                a polygon is completed, the code searches for any additional
                edges that have not yet been committed to a polygon. As they are
                found, the sweep-and-build process continues as described above.
                When no additional uncommitted edges are available, the
                polygon-building portion of the alpha shape algorithm terminates.</p>
            <p>The final step in the process is to collect a list of any individual vertices
                that were not part of the region enclosed by the polygons.
                To do so, Tinfour simply checks for
                any vertices that were not connected to an edge that
                was classified as covered.</p>

            <h3 id="AccomplishingTheSweep">Accomplishing the sweep</h3>
            <p>
                To perform the sweep operation, the AlphaShape class uses the
                forward, dual, and reverse links for each edge. The figure
                below shows a locally concave section of the Delaunay triangulation near
                its upper corner.</p>
            <img width=520 height=320 alt="ConcaveSweep" src="images2/AlphaShapeSectionSweeps.png">
            <p>The selection of starting edge for the polygon building loop
                is arbitrary. Any border edge will do.  For this example, we select
                edge 21 as the starting edge of the polygon building loop.
                Its dual, edge 20, is interior to the alpha shape and would be
                marked as covered. The polygon building logic adds covered
                edges to the alpha-shape polygon and uses the border edges
                to navigate its perimeter. So once edge 20 is added to the polygon,
                the polygon building logic sweeps counter clockwise.
            </p>
            <p>
                In the figure, we labeled  the initial vertex of edge 21 the "Pivot".
                The next edge in the border traversal is edge 15.  Recalling
                that Tinfour gives triangles in counterclockwise order, we see
                that edge 15 is the <i>reverse</i> of edge 21. So for this particular
                layout (a locally concave section of the alpha shape), the transfer is
                simply a matter of moving to the reverse, edge 15. The building logic would
                add the dual of edge 15, edge 14, to the polygon and continue the sweep.
            </p>
            <p>
                The figure below shows a section of a different Delaunay triangulation
                and illustrates a case where the alpha shape would be
                is locally convex.  In that case, the traversal is a little more complicated.
                If the algorithm was positioned at edge 507
                the sweep would have to traverse across four α-exposed edges in order
                to reach the next border segment (edge 501). </p>

            <img width="780" height="536" alt="ConvexSection" src="images2/AlphaShapeSectionS2.png"/>

            <p>The observation that the traversal must sometimes cross multiple edges
                leads to a more complete description of the traversal rule:</p>
            <ul>
                <li>For the current edge, obtain its reverse link
                    <ul>
                        <li>If the reverse link is a border, transfer to the reverse.</li>
                        <li>If the reverse link is α-exposed,  transfer to the
                            dual of the the reverse link</li>
                    </ul>
                </li>
            </ul>

            <p>Finally, we note that in the figures above, the sweeps sometimes
                pass outside the convex hull of the Delaunay triangulation.
                To ensure that the Delaunay triangulation link relationships
                are fully populated (reverse, forward, and dual), Tinfour implements
                a set of non-standard edges (so called "ghost edges") which
                lie outside the convex hull. The presence os these edges
                allows the AlphaShape class to apply the traversal rules
                without special considerations.</p>

            <h2 id="optionalModReclassifyEdges">Reclassifying edges based on neighboring triangles</h2>
            <p>Tinfour implements an additional modification to the original alpha shape
                logic by reclassifying some border edges based on the conditions
                of the triangle that it borders. While this idea is not original
                to Tinfour<sup><a href="#Note3">[3]</a></sup>, it is often useful as
                a way of eliminating small holes and cavities from the alpha shape.</p>


            <p>The figure below illustrates a case where the alpha shape is
                simplified by reclassifying edges</p>
            <img width="780" height="400" alt="Reclassify edges"
                 title="Edges to be reclassified"
                 src="images2/AlphaShapeEdgeClassification4.png" />
            <p>The gray filled areas in the image indicates Tinfour's interpretation of
                a modified alpha shape. The right panel shows a close up of the area in the letter A
                with edges color coded to show their classifications. Once again,
                we note that Tinfour edges have two sides. In the figure, some edges
                are labeled on either side with their edge index. Edges <i>0|1</i>,
                <i>2|3</i>, and <i>4|5</i> are border edges. Initially they are assigned
                covered and border flag values as shown in the table below.
            </p>
            <table class="tight">
                <tr>
                    <th class="tight">Side</th>
                    <th class="tight">Classification</th>
                </tr>
                <tr>
                    <td class="tight" >0</td><td class="tight" >Covered (interior-facing)</td>
                </tr>
                <tr>
                    <td class="tight" >1</td><td class="tight" >Border (exterior-facing)</td>
                </tr>
                <tr>
                    <td class="tight" >2</td><td class="tight" >Covered (interior-facing)</td>
                </tr>
                <tr>
                    <td class="tight" >3</td><td class="tight" >Border (exterior-facing)</td>
                </tr>
                <tr>
                    <td class="tight" >4</td><td class="tight" >Border (exterior-facing)</td>
                </tr>
                <tr>
                    <td class="tight" >5</td><td class="tight" >Covered (interior-facing)</td>
                </tr>
            </table>

            <p>Based on the edge classifications, the stich and sweep method described
                above would develop a triangle shaped hole from edges 1, 2, and 4
                (using clockwise order because it is a hole feature).
                In fact, the unmodified edge classifications would result
                in a number of holes and cavities in the shape. But, as the
                table above shows, edge 2 was classified as covered because
                the vertex opposite the edge lies within its alpha circles.
                So edge 2 is an inward-facing side of edge <i>2|3</i>, a situation which
                suggests that &#9651;1,2,4 should be treated as
                an interior triangle. This observation leads to the following rule:</p>

            <p class="blockquote">If either the forward or reverse
                links of a border edge are classified as covered,
                the border edge should be reclassified as covered.</p>

            <p>The figure below shows the effect of the reclassification
                rule. The panel on the left is based on an alpha shape
                constructed without the reclassification rule. The
                panel on the right shows an alpha shape constructed
                with edge-reclassification based on information from
                its facing triangle. The reclassification eliminates
                a number of hole and cavity features, resulting in a
                cleaner presentation.</p>

            <img width="780" height="400" alt="Reclassification comparison"
                 title="Reclassification rule reduces holes and cavities"
                 src="images2/AlphaShapeCompareReclassification.png" />


            <h1 id="algorithmIntro">The algorithm and the implementation</h1>
            <p>
                In the steps below, references "the edges in a Delaunay triangulation" refer
                to the standard (non-ghost) edges in the structure. That is, all edges
                the are enclosed within the convex hull of the triangulation. All
                such edges will have a valid geometry (vertices A and B in the images above),
                though in some cases the references to the opposite vertices
                (vertices C and D in the image above) will be null.
                For implementation purposes, the Tinfour edge iterator provides access
                to all the standard (non ghost) edges in a Delaunay triangulation
                as shown in the code snippet below:
            </p>
            <pre><code>
    for (IQuadEdge edge : tin.edges()) {
       Vertex A = edge.getA(); // initial vertex of edge
       Vertex B = edge.getB(); // second vertex of edge
       Vertex C = edge.getForward().getB();         // vertex opposite edge, for triangle ABC
       Vertex D = edge.getForwardFromDual().getB(); // vertex opposite dual, for triangle BAD
    }
                    </code></pre>

            <h2>Step 1: classify edges</h2>
            <p>Given a valid Delaunay triangulation and a specified alpha radius <i>r</i>:</p>
            <ol id="classifyEdges">
                <li>Obtain maximum edge index, maxEdgeAllocationIndex, allocate boolean arrays
                    for covered[maxEdgeAllocationIndex] and border[maxAllocationIndex].
                    Arrays are initialized to value false.
                </li>
                <li>For each standard edge in triangulation
                    <ol>
                        <li>If the edge is of length greater than or equal to 2&#215;r, it
                            is classified as α-exposed and no further work
                            is required</li>
                        <li>Get vertices A, B, C, and D as described above</li>
                        <li>Construct pair of open circles with alpha radius r using A, B</li>
                        <li>Test vertices C and D to see if they are within left and right circles;
                            if a vertex reference is null, it is treated as outside the circle.
                            <ul>
                                <li>cInside0 = circle.isPointInCircleLeft(C)</li>
                                <li>cInside1 = circle.isPointInCircleRight(C)</li>
                                <li>dInside0 = circle.isPointInCircleLeft(D)</li>
                                <li>dInside1 = circle.isPointInCircleRight(D)</li>
                            </ul>
                        </li>
                        <li>Using edge index eIndex for edge and dIndex for dual,
                            populate covered[] and border[] array elements as follows:
                            <ul>
                                <li>A side of the edge is considered occupied if
                                    <i>either or both</i> of the alpha circles contains
                                    the vertex on that side.</li>
                                <li>If both sides of the edge (the C side and the D side)
                                    are occupied, the edge is covered.</li>
                                <li>If the left side (C side) is occupied and the
                                    right side (D side) is not occupied, then the left side is
                                    covered (covered[eIndex] = true) and the right side
                                    is a border (border[dIndex] = true).</li>
                                <li>If the right side (D side) is occupied and the
                                    left side (C side) is not occupied, then the left side is
                                    a border (border[eIndex] = true) and the right side
                                    is covered (covered[dIndex] = true).</li>
                            </ul>
                        </li>
                    </ol>
                </li>
            </ol>

            <h2 id="reclassifyEdges">Step 1a: Reclassify edges based on neighboring triangles</h2>
            <p> <b>More content to come:</b> Outline steps for reclassification.</p>


            <h2 id="assemblePolygons">Step 2: Assemble alpha polygons</h2>
            <p>
                The Tinfour edge iterator loops through pairs of edges. So in
                the outline below, there is a test to see whether either an edge,
                or its dual, is a border.  Because the main loop iterates
                through all polygons in the triangulation, it maintains an array
                called "visited" to keep track of which edges are added to
                an alpha polygon. This array is used to prevent edges from being
                processed more than one.</p>
            <ol>
                <li>Allocate an array visited[maxEdgeAllocationIndex] and initialize
                    it to value false to indicate when edges are  processed</li>
                <li>Find a starting edge for a polygon.  For each edge in
                    the Delaunay triangulation:
                    <ul>
                        <li>If the visited array indicates that the edge has already been
                            processed. Continue to the next edge in the iteration.</li>
                        <li>If the edge is a border, then assign it as the starting edge</li>
                        <li>If the dual is a border, then assign it as the starting edge</li>
                        <li>If neither edge is a unprocessed border, continue to the next
                            edge in the iteration.</li>
                    </ul>
                </li>
                <li>Initialize a new polygon.</li>
                <li>Set a traversal edge reference, e, to the starting edge: e=starting edge</li>
                <li>The polygon-build loop: Repeat the following steps:
                    <ol class="innerList">
                        <li>If the edge is a border or a covered edge:
                            <ul>
                                <li>Mark the e as visited and e&#46;getDual() as visited
                                    (<i>i&#46;e&#46;</i> both sides of the edge are marked as visited).</li>
                                <li>Add the dual of the edge to the polygon</li>
                                <li>Advance the traversal edge, e, to the next edge in the sweep
                                    by setting e=e&#46;getReverse()</li>
                            </ul>
                        </li>
                        <li>If the edge is uncovered:
                            <ul>
                                <li>Advance the traversal edge, e, to the next
                                    edge in the sweep by setting e=e&#46;getDual()&#46;getReverse().
                                    This action effectively skips over the uncovered edge</li>
                            </ul>
                        </li>
                        <li>The polygon-build loop terminates when e equals the starting edge.</li>
                    </ol>
                </li>
            </ol>

            <h2 id="assembleOrphans">Step 3: Assemble orphan vertices</h2>
            <p>The assemble polygons step will have set visited flags for any edge that
                was identified as being part of the alpha shape. If the alpha radius is
                sufficiently small, there may exist additional vertices in the Delaunay
                triangulation that were not associated with an incorporated edge.
                Add these vertices to a list of unassociated vertices.</p>

            <ol>
                <li>For each edge in the Delaunay triangulation that is
                    not covered, not a border, and not visited, perform
                    the following for <b>both</b> the edge and its dual:
                    <ul>
                        <li>Determine whether the initial vertex connects to an
                            edge that is covered or that has already been processed.
                            If not, perform the following:
                            <ol class="innerList">
                                <li>Set a flag called uncommitted to true.
                                <li>Loop on each edge that starts with vertex
                                    A (in Tinfour, this action is accomplished
                                    using the "pinwheel" iterator).
                                    <ul>
                                        <li>If the loop-edge is covered, a border, or
                                            visited, set uncommitted to false</li>
                                        <li>Mark the loop-edge as visited.</li>
                                    </ul>
                                </li>
                                <li>If the uncommited flag is true, then the
                                    starting vertex for the edge is an unassociated
                                    vertex.  Add it to the collection of
                                    unassociated vertices</li>
                            </ol>
                        </li>
                    </ul>
                </li>
            </ol>

            <p>Note that in the description above, the inner loop only
                sets the visited flag for one side of the edges. So, if the logic
                is processing the edge AB, the first
                time the inner loop executes (for the edge), only the sides
                of the edges directed away from point A are marked as visited.
                Then, as it processed the dual, BA, the sides of the edges
                directed away from point B will be marked as visited.
                This approach ensures that both endpoints for an uncovered
                edge are correctly processed and that no vertex is added to
                the unassociated vertices collection more than once.</p>

            <h1 id="Conclusion">Conclusion</h1>
            <p><strong>More content to come:</strong>
                Add a conclusion.  Talk about future work, especially where
                proofs are needed. Mention the example class
                AlphaShapeDemoImage.java from the Tinfour code distribution.
            </p>

            <h1 id="Notes">Notes</h1>
            <p id="Note1">
                [1] Edelsbrunner, et al., original paper treats border edges
                as α-exposed. That choice reflects the mathematical
                basis for their proofs and derivation (as does the choice of
                open circles versus closed circles for the edge selection
                criterion). To distinguish implementation considerations
                the Tinfour code does not use the term "unexposed". Instead,
                it uses the term "covered" to refer to edges that are
                either α-unexposed (interior) or part of the border.
            </p>

            <p id="Note2">
                [2] For clarity, it is worth noting that what Tinfour
                calls an "edge" is usually just a single side of a
                bidirectional segment created between two vertices
                in the Delaunay triangulation.
            </p>

            <p id="Note3">[3] Tinfour's edge reclassification technique was suggested,
                in part, by an example provided on the stackoverflow website
                at <a href="https://stackoverflow.com/a/23073229/12664668">
                    https://stackoverflow.com/a/23073229/12664668</a>.
            </p>

            <h1 id="References">References</h1>
            <p>Edelsbrunner, Herbert; Kirkpatrick, David G.; Seidel, Raimund. (1983).
                On the shape of a set of points in the plane,
                <i>IEEE Transactions on Information Theory</i>, 29 (4): 551–559, doi:10.1109/TIT.1983.1056714.
            </p>


        </div>
    </div>
</body>

